#!/usr/bin/env python3
from bleak import BleakClient, BleakScanner
import asyncio
import sys
import struct
import queue
import xxtea
import json

def checksum(data):
    i = 0
    for b in data:
        i += b
    return struct.pack("B", i % 256)

notify_uuid = "7365642e-6a69-7561-6e2e-485332533032"
write_uuid = "7265632e-6a69-7561-6e2e-485332533032"

q = queue.Queue()

def notify_callback(sender: int, data: bytearray):
    q.put(data)

# from file: com/ihealth/communication/ins/Hs2sProInsSet.java
# from function: public final JSONObject g(byte[] bArr)
def decode_offline_data_chuck(bArr,instruction_type):
    data = {}
    data["instruction_type"] = instruction_type
    data["weight"] = (((bArr[0] & 255) * 256) + (bArr[1] & 255)) / 100
    data["impedance1"] = ((bArr[2] & 255) * 256) + (bArr[3] & 255)
    data["impedance2"] = ((bArr[4] & 255) * 256) + (bArr[5] & 255)
    data["impedance3"] = ((bArr[6] & 255) * 256) + (bArr[7] & 255)
    data["impedance4"] = ((bArr[8] & 255) * 256) + (bArr[9] & 255)
    data["user_num"] = bArr[10] & 255
    data["gender"] = bArr[11] & 255
    data["age"] = bArr[12] & 255
    data["height"] = bArr[13] & 255
    data["dataID"] = (bArr[16] * bArr[15]) + bArr[14] + bArr[17]
    data["right_time"] = bArr[18] & 255
    data["body_building"] = bArr[19] & 255
    data["data_impedance_errors"] = bArr[20] & 255
    data["body_fit_percentage"] = (((bArr[21] & 255) * 256) + (bArr[22] & 255)) / 10.0
    data["muscle_mas"] = (((bArr[23] & 255) * 256) + (bArr[24] & 255)) / 10.0
    data["bone_salt_content"] = (bArr[25] & 255) / 10.0
    data["body_water_rate"] = (((bArr[26] & 255) * 256) + (bArr[27] & 255)) / 10.0
    data["protein_rate"] = (((bArr[28] & 255) * 256) + (bArr[29] & 255)) / 10.0
    data["impedanceEncrypt"] = 'idk' # uses byte 30 - 34
    return data

def decode_offline_data(packet):
    bArr = packet[9:]
    offline_data = []
    instruction_type = bArr[0] # parsing here b/c in multi reading packet this only appears once
    bArr = bArr[1:]
    while len(bArr) >= 35:
        offline_data.append(decode_offline_data_chuck(bArr[:35],instruction_type))
        bArr = bArr[35:]
    return offline_data

async def run(macaddr):
    client = BleakClient(macaddr)
    ret = True
    try:
        await client.connect()
        print("INFO: connected to "+ macaddr)
        await client.start_notify(notify_uuid,notify_callback)

        # create R1 challenge for device
        r1 = bytes.fromhex("deadbeefdeadbeefdeadbeefdeadbeef")
        d1 = bytes.fromhex("b0140001a9fa") + r1
        d1 += checksum(d1[2:])
        # send R1
        print(f"SEND: {d1.hex()}")
        await client.write_gatt_char(write_uuid,d1)
        await asyncio.sleep(1.0)

        # get device R2 response
        data = q.get()
        print(f"RECV: {data.hex()}")
        xxtea_padding = bytes.fromhex("10000000")
        # get R2 and MAC buffer
        R2 = data[6:22]
        R1_stroke = data[22:42]
        mac = data[42:58]

        print("INFO: Performing Device Auth Calculations")
        print("            R2: " + R2.hex())
        print("     R1_stroke: " + R1_stroke.hex())
        print("    MAC BUFFER: " + mac.hex())

        # calculate ka
        super_secret_hardcoded_key = bytes.fromhex("b3c9d23d155fce5e51e7c8a2fed48e89")
        ka = xxtea.encrypt(mac+xxtea_padding,super_secret_hardcoded_key,padding=False)[:16]
        print("            ka: " + ka.hex())

        # skipping auth of device step... we don't care

        # calc R2_stroke
        R2_stroke = xxtea.encrypt(R2+xxtea_padding,ka,padding=False)
        print("     R2_stroke: " + R2_stroke.hex())
        d2 = bytes.fromhex("B0180003A9FC") + R2_stroke
        d2 += checksum(d2[2:])

        # Send R2_stroke
        print(f"SEND: {d2.hex()}")
        await client.write_gatt_char(write_uuid,d2)
        await asyncio.sleep(1.0)
        data = q.get()
        print(f"RECV: {data.hex()}")


        # Request offline data
        d3 = bytes.fromhex("b016000fa93130033079ba8249f28c4626fe1804e8ec000022")
        print(f"SEND: {d3.hex()}")
        await client.write_gatt_char(write_uuid,d3)
        await asyncio.sleep(1.0)
        data = q.get()
        print(f"RECV: {data.hex()}")
        if len(data) > 45:
            print("INFO: Received offline data!")
            offline_data = decode_offline_data(data)
            for d in offline_data:
                print(json.dumps(d, indent=4))
        else:
            print("INFO: No offline data available")


        await client.stop_notify(notify_uuid)
    except Exception as e:
        print(e)
        ret = False
    finally:
        await client.disconnect()
    return ret

macaddr = sys.argv[1]
ret = asyncio.run(run(macaddr))

if not ret:
    print("ble error")
